using BAAP.API.Models;
using BAAP.API.Data;

namespace BAAP.API.Services;

public interface IPredictiveAnalyticsService
{
    Task<MigrationTimelinePrediction> PredictMigrationTimelineAsync(string assessmentId);
    Task<List<TimelineScenario>> GenerateTimelineScenariosAsync(string assessmentId, TimelineParameters parameters);
    Task<CriticalPathAnalysis> AnalyzeCriticalPathAsync(string assessmentId);
    Task<List<MigrationBottleneck>> IdentifyBottlenecksAsync(string assessmentId);
    Task<TimelineOptimizationSuggestions> OptimizeTimelineAsync(string assessmentId, OptimizationCriteria criteria);
    Task<ResourceAllocationPrediction> PredictResourceRequirementsAsync(string assessmentId);
    Task<List<MilestonePrediction>> PredictMilestonesAsync(string assessmentId);
    Task<TimelineRiskAssessment> AssessTimelineRisksAsync(string assessmentId);
}

public class PredictiveAnalyticsService : IPredictiveAnalyticsService
{
    private readonly ISemanticKernelService _semanticKernel;
    private readonly BaapDbContext _context;
    private readonly ILogger<PredictiveAnalyticsService> _logger;

    public PredictiveAnalyticsService(
        ISemanticKernelService semanticKernel,
        BaapDbContext context,
        ILogger<PredictiveAnalyticsService> logger)
    {
        _semanticKernel = semanticKernel;
        _context = context;
        _logger = logger;
    }

    public async Task<MigrationTimelinePrediction> PredictMigrationTimelineAsync(string assessmentId)
    {
        try
        {
            var assessment = await _context.Assessments
                .Include(a => a.Applications)
                .FirstOrDefaultAsync(a => a.Id == assessmentId);

            if (assessment == null)
                throw new ArgumentException($"Assessment {assessmentId} not found");

            var applications = assessment.Applications.ToList();
            var complexity = await CalculatePortfolioComplexity(applications);
            var dependencies = await AnalyzeApplicationDependencies(applications);
            
            // AI-powered timeline prediction
            var systemPrompt = @"You are an expert cloud migration consultant and project manager with 15+ years of experience in enterprise migrations.
                Analyze the application portfolio and predict realistic migration timelines based on:
                - Application complexity and technology stack
                - Dependencies and integration patterns
                - Team capacity and skill requirements
                - Risk factors and potential blockers
                - Industry best practices and historical data
                
                Provide detailed timeline predictions with confidence intervals and risk assessments.";

            var userPrompt = $@"Analyze this application portfolio for migration timeline prediction:

Portfolio Overview:
- Total Applications: {applications.Count}
- Average Complexity Score: {complexity.AverageComplexity:F1}
- High Complexity Apps: {complexity.HighComplexityCount}
- Critical Dependencies: {dependencies.CriticalDependencies}
- Integration Points: {dependencies.IntegrationPoints}

Application Details:
{string.Join("\n", applications.Take(10).Select(a => 
    $"â€¢ {a.Name} - Technology: {a.TechnologyStack}, Complexity: {CalculateApplicationComplexity(a):F1}, Dependencies: {GetDependencyCount(a)}"))}

Please provide:
1. Overall timeline prediction (optimistic, realistic, pessimistic)
2. Phase-by-phase breakdown (Assessment, Design, Migration, Testing, Go-Live)
3. Critical path analysis
4. Resource requirements by phase
5. Key risk factors and mitigation strategies
6. Parallel execution opportunities
7. Dependency resolution timeline

Format as structured analysis with specific timeframes and confidence levels.";

            var aiResponse = await _semanticKernel.GetChatResponseAsync(userPrompt, systemPrompt);
            
            // Parse AI response and generate structured prediction
            var prediction = await ParseTimelinePrediction(aiResponse, applications, complexity, dependencies);
            
            prediction.GeneratedAt = DateTime.UtcNow;
            prediction.ConfidenceScore = CalculateConfidenceScore(complexity, dependencies);
            
            return prediction;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error predicting migration timeline for assessment {AssessmentId}", assessmentId);
            return GenerateDefaultTimelinePrediction(assessmentId);
        }
    }

    public async Task<List<TimelineScenario>> GenerateTimelineScenariosAsync(string assessmentId, TimelineParameters parameters)
    {
        var scenarios = new List<TimelineScenario>();
        
        try
        {
            var basePrediction = await PredictMigrationTimelineAsync(assessmentId);
            
            // Generate optimistic scenario (best case)
            scenarios.Add(new TimelineScenario
            {
                Name = "Optimistic",
                Description = "Best-case scenario with minimal blockers and optimal resource allocation",
                TotalDuration = TimeSpan.FromDays(basePrediction.OptimisticTimeline.TotalDays * 0.85),
                Probability = 0.15,
                KeyAssumptions = new List<string>
                {
                    "No major technical blockers encountered",
                    "Full team availability throughout project",
                    "Minimal scope changes or requirements drift",
                    "Efficient stakeholder decision-making",
                    "No critical dependency delays"
                },
                RiskLevel = RiskLevel.Low,
                ResourceEfficiency = 0.95
            });

            // Generate realistic scenario (most likely)
            scenarios.Add(new TimelineScenario
            {
                Name = "Realistic",
                Description = "Most likely scenario based on typical enterprise migration patterns",
                TotalDuration = basePrediction.RealisticTimeline,
                Probability = 0.60,
                KeyAssumptions = new List<string>
                {
                    "Standard project challenges and minor delays",
                    "Occasional resource constraints",
                    "Some scope adjustments during execution",
                    "Normal stakeholder approval cycles",
                    "Manageable dependency complexities"
                },
                RiskLevel = RiskLevel.Medium,
                ResourceEfficiency = 0.80
            });

            // Generate pessimistic scenario (worst case)
            scenarios.Add(new TimelineScenario
            {
                Name = "Pessimistic",
                Description = "Worst-case scenario with multiple complications and delays",
                TotalDuration = TimeSpan.FromDays(basePrediction.PessimisticTimeline.TotalDays * 1.25),
                Probability = 0.25,
                KeyAssumptions = new List<string>
                {
                    "Significant technical challenges and blockers",
                    "Resource shortages and skill gaps",
                    "Major scope changes and requirements evolution",
                    "Extended approval and decision cycles",
                    "Complex dependency resolution issues",
                    "Vendor delays or licensing complications"
                },
                RiskLevel = RiskLevel.High,
                ResourceEfficiency = 0.65
            });

            foreach (var scenario in scenarios)
            {
                scenario.PhaseBreakdown = GeneratePhaseBreakdown(scenario.TotalDuration);
                scenario.MilestoneDates = CalculateMilestoneDates(scenario.TotalDuration);
            }
            
            return scenarios;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating timeline scenarios for assessment {AssessmentId}", assessmentId);
            return new List<TimelineScenario>();
        }
    }

    public async Task<CriticalPathAnalysis> AnalyzeCriticalPathAsync(string assessmentId)
    {
        try
        {
            var assessment = await _context.Assessments
                .Include(a => a.Applications)
                .FirstOrDefaultAsync(a => a.Id == assessmentId);

            if (assessment == null)
                throw new ArgumentException($"Assessment {assessmentId} not found");

            var applications = assessment.Applications.ToList();
            var dependencies = await AnalyzeApplicationDependencies(applications);
            
            // Identify critical path components
            var criticalActivities = new List<CriticalActivity>();
            
            // Phase 1: Assessment and Planning
            criticalActivities.Add(new CriticalActivity
            {
                Name = "Detailed Application Assessment",
                Duration = TimeSpan.FromDays(applications.Count * 2), // 2 days per app
                Dependencies = new List<string>(),
                Phase = "Assessment",
                ResourceRequirement = ResourceType.ArchitectAnalyst,
                IsCritical = true,
                BufferTime = TimeSpan.FromDays(applications.Count * 0.5)
            });

            // Phase 2: Infrastructure Preparation
            if (dependencies.RequiresInfrastructure)
            {
                criticalActivities.Add(new CriticalActivity
                {
                    Name = "Cloud Infrastructure Setup",
                    Duration = TimeSpan.FromDays(14),
                    Dependencies = new List<string> { "Detailed Application Assessment" },
                    Phase = "Infrastructure",
                    ResourceRequirement = ResourceType.CloudEngineer,
                    IsCritical = true,
                    BufferTime = TimeSpan.FromDays(3)
                });
            }

            // Phase 3: Application Migration (Critical Path)
            var complexApplications = applications
                .Where(a => CalculateApplicationComplexity(a) > 7.0)
                .OrderByDescending(a => GetDependencyCount(a))
                .Take(5);

            foreach (var app in complexApplications)
            {
                var migrationDuration = EstimateApplicationMigrationDuration(app);
                criticalActivities.Add(new CriticalActivity
                {
                    Name = $"Migrate {app.Name}",
                    Duration = migrationDuration,
                    Dependencies = GetApplicationDependencies(app, applications),
                    Phase = "Migration",
                    ResourceRequirement = GetRequiredResourceType(app),
                    IsCritical = true,
                    BufferTime = TimeSpan.FromDays(migrationDuration.TotalDays * 0.2)
                });
            }

            // Calculate critical path
            var totalCriticalPathDuration = CalculateCriticalPathDuration(criticalActivities);
            var bottlenecks = IdentifyCriticalPathBottlenecks(criticalActivities);
            
            return new CriticalPathAnalysis
            {
                TotalDuration = totalCriticalPathDuration,
                CriticalActivities = criticalActivities,
                Bottlenecks = bottlenecks,
                ParallelizationOpportunities = IdentifyParallelizationOpportunities(criticalActivities),
                ResourceConstraints = AnalyzeResourceConstraints(criticalActivities),
                OptimizationSuggestions = GenerateCriticalPathOptimizations(criticalActivities),
                AnalysisDate = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error analyzing critical path for assessment {AssessmentId}", assessmentId);
            throw;
        }
    }

    public async Task<List<MigrationBottleneck>> IdentifyBottlenecksAsync(string assessmentId)
    {
        var bottlenecks = new List<MigrationBottleneck>();
        
        try
        {
            var assessment = await _context.Assessments
                .Include(a => a.Applications)
                .FirstOrDefaultAsync(a => a.Id == assessmentId);

            if (assessment == null) return bottlenecks;

            var applications = assessment.Applications.ToList();
            
            // Resource bottlenecks
            var resourceConstraints = AnalyzeResourceAvailability(applications);
            if (resourceConstraints.Any(r => r.UtilizationRate > 0.9))
            {
                bottlenecks.Add(new MigrationBottleneck
                {
                    Type = BottleneckType.Resource,
                    Name = "Resource Capacity Constraint",
                    Description = "High resource utilization may cause delays",
                    Impact = BottleneckImpact.High,
                    AffectedApplications = applications.Take(10).Select(a => a.Name).ToList(),
                    EstimatedDelay = TimeSpan.FromDays(14),
                    MitigationStrategies = new List<string>
                    {
                        "Increase team capacity through contractors",
                        "Parallelize non-dependent activities",
                        "Implement phased migration approach",
                        "Cross-train team members"
                    }
                });
            }

            // Dependency bottlenecks
            var highDependencyApps = applications
                .Where(a => GetDependencyCount(a) > 5)
                .ToList();

            if (highDependencyApps.Any())
            {
                bottlenecks.Add(new MigrationBottleneck
                {
                    Type = BottleneckType.Dependency,
                    Name = "Complex Application Dependencies",
                    Description = "Applications with high dependency counts will create migration bottlenecks",
                    Impact = BottleneckImpact.High,
                    AffectedApplications = highDependencyApps.Select(a => a.Name).ToList(),
                    EstimatedDelay = TimeSpan.FromDays(21),
                    MitigationStrategies = new List<string>
                    {
                        "Decouple applications before migration",
                        "Implement API gateways for external dependencies",
                        "Create migration staging environments",
                        "Establish dependency resolution team"
                    }
                });
            }

            // Technology bottlenecks
            var legacyTechApps = applications
                .Where(a => IsLegacyTechnology(a.TechnologyStack))
                .ToList();

            if (legacyTechApps.Any())
            {
                bottlenecks.Add(new MigrationBottleneck
                {
                    Type = BottleneckType.Technology,
                    Name = "Legacy Technology Stack",
                    Description = "Legacy technologies require specialized expertise and longer migration times",
                    Impact = BottleneckImpact.Medium,
                    AffectedApplications = legacyTechApps.Select(a => a.Name).ToList(),
                    EstimatedDelay = TimeSpan.FromDays(10),
                    MitigationStrategies = new List<string>
                    {
                        "Engage legacy technology specialists",
                        "Plan for application modernization",
                        "Consider lift-and-shift vs. re-architecture",
                        "Implement gradual technology upgrades"
                    }
                });
            }

            return bottlenecks;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error identifying bottlenecks for assessment {AssessmentId}", assessmentId);
            return bottlenecks;
        }
    }

    public async Task<TimelineOptimizationSuggestions> OptimizeTimelineAsync(string assessmentId, OptimizationCriteria criteria)
    {
        try
        {
            var criticalPath = await AnalyzeCriticalPathAsync(assessmentId);
            var bottlenecks = await IdentifyBottlenecksAsync(assessmentId);
            
            var optimizations = new List<OptimizationSuggestion>();

            // Parallelization optimizations
            if (criteria.OptimizeFor.HasFlag(OptimizationGoal.Speed))
            {
                optimizations.AddRange(GenerateParallelizationSuggestions(criticalPath));
            }

            // Resource optimization
            if (criteria.OptimizeFor.HasFlag(OptimizationGoal.ResourceEfficiency))
            {
                optimizations.AddRange(GenerateResourceOptimizations(criticalPath, bottlenecks));
            }

            // Risk mitigation optimizations
            if (criteria.OptimizeFor.HasFlag(OptimizationGoal.RiskReduction))
            {
                optimizations.AddRange(GenerateRiskMitigationOptimizations(bottlenecks));
            }

            var potentialTimeSavings = optimizations.Sum(o => o.EstimatedTimeSavings.TotalDays);
            var implementationComplexity = CalculateImplementationComplexity(optimizations);

            return new TimelineOptimizationSuggestions
            {
                Suggestions = optimizations,
                PotentialTimeSavings = TimeSpan.FromDays(potentialTimeSavings),
                ImplementationComplexity = implementationComplexity,
                RecommendedApproach = DetermineRecommendedApproach(optimizations, criteria),
                RiskAssessment = AssessOptimizationRisks(optimizations),
                CostBenefitAnalysis = CalculateCostBenefitAnalysis(optimizations),
                GeneratedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error optimizing timeline for assessment {AssessmentId}", assessmentId);
            throw;
        }
    }

    public async Task<ResourceAllocationPrediction> PredictResourceRequirementsAsync(string assessmentId)
    {
        try
        {
            var assessment = await _context.Assessments
                .Include(a => a.Applications)
                .FirstOrDefaultAsync(a => a.Id == assessmentId);

            if (assessment == null)
                throw new ArgumentException($"Assessment {assessmentId} not found");

            var applications = assessment.Applications.ToList();
            var timeline = await PredictMigrationTimelineAsync(assessmentId);
            
            var resourcePrediction = new ResourceAllocationPrediction
            {
                AssessmentId = assessmentId,
                PredictionDate = DateTime.UtcNow,
                TimelineDuration = timeline.RealisticTimeline,
                PhaseResources = new List<PhaseResourceRequirement>()
            };

            // Assessment Phase
            resourcePrediction.PhaseResources.Add(new PhaseResourceRequirement
            {
                Phase = "Assessment & Planning",
                Duration = TimeSpan.FromDays(applications.Count * 1.5),
                ResourceNeeds = new List<ResourceNeed>
                {
                    new() { Role = "Solution Architect", FTE = 1.0, Criticality = ResourceCriticality.Critical },
                    new() { Role = "Business Analyst", FTE = 0.5, Criticality = ResourceCriticality.High },
                    new() { Role = "Technical Analyst", FTE = 2.0, Criticality = ResourceCriticality.High }
                }
            });

            // Infrastructure Phase
            resourcePrediction.PhaseResources.Add(new PhaseResourceRequirement
            {
                Phase = "Infrastructure Setup",
                Duration = TimeSpan.FromDays(21),
                ResourceNeeds = new List<ResourceNeed>
                {
                    new() { Role = "Cloud Architect", FTE = 1.0, Criticality = ResourceCriticality.Critical },
                    new() { Role = "DevOps Engineer", FTE = 2.0, Criticality = ResourceCriticality.Critical },
                    new() { Role = "Network Engineer", FTE = 0.5, Criticality = ResourceCriticality.Medium },
                    new() { Role = "Security Engineer", FTE = 0.5, Criticality = ResourceCriticality.High }
                }
            });

            // Migration Phase
            var migrationComplexity = CalculatePortfolioComplexity(applications);
            var migrationDuration = TimeSpan.FromDays(applications.Count * migrationComplexity.AverageComplexity * 3);

            resourcePrediction.PhaseResources.Add(new PhaseResourceRequirement
            {
                Phase = "Migration Execution",
                Duration = migrationDuration,
                ResourceNeeds = new List<ResourceNeed>
                {
                    new() { Role = "Migration Engineer", FTE = 3.0, Criticality = ResourceCriticality.Critical },
                    new() { Role = "Database Specialist", FTE = 1.0, Criticality = ResourceCriticality.High },
                    new() { Role = "Application Developer", FTE = 2.0, Criticality = ResourceCriticality.High },
                    new() { Role = "QA Engineer", FTE = 1.5, Criticality = ResourceCriticality.Medium },
                    new() { Role = "DevOps Engineer", FTE = 1.0, Criticality = ResourceCriticality.High }
                }
            });

            // Testing & Validation Phase
            resourcePrediction.PhaseResources.Add(new PhaseResourceRequirement
            {
                Phase = "Testing & Validation",
                Duration = TimeSpan.FromDays(applications.Count * 2),
                ResourceNeeds = new List<ResourceNeed>
                {
                    new() { Role = "QA Lead", FTE = 1.0, Criticality = ResourceCriticality.Critical },
                    new() { Role = "Test Engineer", FTE = 2.0, Criticality = ResourceCriticality.High },
                    new() { Role = "Performance Engineer", FTE = 0.5, Criticality = ResourceCriticality.Medium },
                    new() { Role = "Business User", FTE = 1.0, Criticality = ResourceCriticality.High }
                }
            });

            // Calculate total resource requirements
            resourcePrediction.TotalResourceRequirement = CalculateTotalResourceRequirement(resourcePrediction.PhaseResources);
            resourcePrediction.PeakResourceRequirement = CalculatePeakResourceRequirement(resourcePrediction.PhaseResources);
            resourcePrediction.SkillGapAnalysis = AnalyzeSkillGaps(resourcePrediction.PhaseResources, applications);

            return resourcePrediction;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error predicting resource requirements for assessment {AssessmentId}", assessmentId);
            throw;
        }
    }

    public async Task<List<MilestonePrediction>> PredictMilestonesAsync(string assessmentId)
    {
        try
        {
            var timeline = await PredictMigrationTimelineAsync(assessmentId);
            var startDate = DateTime.UtcNow;
            var milestones = new List<MilestonePrediction>();

            // Assessment Complete
            milestones.Add(new MilestonePrediction
            {
                Name = "Assessment Complete",
                Description = "Detailed technical and business assessment finished",
                PredictedDate = startDate.AddDays(timeline.PhaseBreakdown["Assessment"].TotalDays),
                Confidence = 0.85,
                CriticalPath = true,
                Dependencies = new List<string> { "Project Kickoff", "Stakeholder Interviews" },
                SuccessCriteria = new List<string>
                {
                    "All applications analyzed and documented",
                    "Technical requirements defined",
                    "Business case validated",
                    "Migration strategy approved"
                }
            });

            // Infrastructure Ready
            var infrastructureDate = startDate.AddDays(
                timeline.PhaseBreakdown["Assessment"].TotalDays + 
                timeline.PhaseBreakdown["Infrastructure"].TotalDays);

            milestones.Add(new MilestonePrediction
            {
                Name = "Cloud Infrastructure Ready",
                Description = "Target cloud infrastructure provisioned and configured",
                PredictedDate = infrastructureDate,
                Confidence = 0.78,
                CriticalPath = true,
                Dependencies = new List<string> { "Assessment Complete", "Cloud Subscription Setup" },
                SuccessCriteria = new List<string>
                {
                    "Network connectivity established",
                    "Security controls implemented",
                    "Monitoring and logging configured",
                    "Backup and disaster recovery ready"
                }
            });

            // First Application Migrated
            var firstMigrationDate = infrastructureDate.AddDays(14);
            milestones.Add(new MilestonePrediction
            {
                Name = "First Application Migrated",
                Description = "Proof of concept migration completed successfully",
                PredictedDate = firstMigrationDate,
                Confidence = 0.72,
                CriticalPath = true,
                Dependencies = new List<string> { "Cloud Infrastructure Ready", "Migration Tools Ready" },
                SuccessCriteria = new List<string>
                {
                    "Application successfully migrated",
                    "Functionality validated",
                    "Performance benchmarks met",
                    "User acceptance testing passed"
                }
            });

            // 50% Applications Migrated
            var halfwayDate = startDate.AddDays(timeline.RealisticTimeline.TotalDays * 0.7);
            milestones.Add(new MilestonePrediction
            {
                Name = "50% Applications Migrated",
                Description = "Half of the application portfolio successfully migrated",
                PredictedDate = halfwayDate,
                Confidence = 0.68,
                CriticalPath = false,
                Dependencies = new List<string> { "First Application Migrated", "Migration Process Refined" },
                SuccessCriteria = new List<string>
                {
                    "50% of applications running in cloud",
                    "No critical issues outstanding",
                    "Performance targets achieved",
                    "User satisfaction maintained"
                }
            });

            // Migration Complete
            var migrationCompleteDate = startDate.AddDays(timeline.RealisticTimeline.TotalDays * 0.9);
            milestones.Add(new MilestonePrediction
            {
                Name = "Migration Complete",
                Description = "All applications successfully migrated to cloud",
                PredictedDate = migrationCompleteDate,
                Confidence = 0.75,
                CriticalPath = true,
                Dependencies = new List<string> { "50% Applications Migrated", "Final Testing Complete" },
                SuccessCriteria = new List<string>
                {
                    "100% of applications migrated",
                    "All integration points validated",
                    "Performance optimization complete",
                    "Security audit passed"
                }
            });

            // Project Go-Live
            milestones.Add(new MilestonePrediction
            {
                Name = "Project Go-Live",
                Description = "Full production deployment and project closure",
                PredictedDate = startDate.Add(timeline.RealisticTimeline),
                Confidence = 0.82,
                CriticalPath = true,
                Dependencies = new List<string> { "Migration Complete", "Final User Training" },
                SuccessCriteria = new List<string>
                {
                    "All systems operational in production",
                    "Users successfully transitioned",
                    "Documentation complete",
                    "Support processes established",
                    "Project benefits realized"
                }
            });

            return milestones;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error predicting milestones for assessment {AssessmentId}", assessmentId);
            throw;
        }
    }

    public async Task<TimelineRiskAssessment> AssessTimelineRisksAsync(string assessmentId)
    {
        try
        {
            var assessment = await _context.Assessments
                .Include(a => a.Applications)
                .FirstOrDefaultAsync(a => a.Id == assessmentId);

            if (assessment == null)
                throw new ArgumentException($"Assessment {assessmentId} not found");

            var applications = assessment.Applications.ToList();
            var risks = new List<TimelineRisk>();

            // Technical complexity risks
            var complexApplications = applications.Where(a => CalculateApplicationComplexity(a) > 8.0).ToList();
            if (complexApplications.Any())
            {
                risks.Add(new TimelineRisk
                {
                    Name = "High Technical Complexity",
                    Description = $"{complexApplications.Count} applications have high complexity scores that may cause delays",
                    Impact = RiskImpact.High,
                    Probability = 0.65,
                    EstimatedDelay = TimeSpan.FromDays(complexApplications.Count * 5),
                    Category = RiskCategory.Technical,
                    MitigationStrategies = new List<string>
                    {
                        "Conduct detailed technical spikes for complex applications",
                        "Allocate additional senior technical resources",
                        "Consider phased migration approach",
                        "Implement comprehensive testing strategy"
                    }
                });
            }

            // Resource availability risks
            risks.Add(new TimelineRisk
            {
                Name = "Resource Availability",
                Description = "Limited availability of specialized cloud migration skills",
                Impact = RiskImpact.Medium,
                Probability = 0.45,
                EstimatedDelay = TimeSpan.FromDays(14),
                Category = RiskCategory.Resource,
                MitigationStrategies = new List<string>
                {
                    "Engage external consultants or contractors",
                    "Cross-train internal team members",
                    "Stagger project phases to optimize resource utilization",
                    "Establish partnerships with cloud service providers"
                }
            });

            // Dependency risks
            var highDependencyCount = applications.Sum(a => GetDependencyCount(a));
            if (highDependencyCount > applications.Count * 3)
            {
                risks.Add(new TimelineRisk
                {
                    Name = "Complex Dependencies",
                    Description = "High number of application dependencies may cause cascading delays",
                    Impact = RiskImpact.High,
                    Probability = 0.55,
                    EstimatedDelay = TimeSpan.FromDays(21),
                    Category = RiskCategory.Dependency,
                    MitigationStrategies = new List<string>
                    {
                        "Create detailed dependency mapping",
                        "Implement staged migration approach",
                        "Establish clear integration testing protocols",
                        "Develop contingency plans for critical dependencies"
                    }
                });
            }

            // Scope creep risks
            risks.Add(new TimelineRisk
            {
                Name = "Scope Creep",
                Description = "Additional requirements discovered during migration may extend timeline",
                Impact = RiskImpact.Medium,
                Probability = 0.70,
                EstimatedDelay = TimeSpan.FromDays(10),
                Category = RiskCategory.Scope,
                MitigationStrategies = new List<string>
                {
                    "Implement rigorous change control process",
                    "Maintain detailed requirements documentation",
                    "Regular stakeholder communication and expectation management",
                    "Plan buffer time for scope adjustments"
                }
            });

            var overallRiskScore = CalculateOverallRiskScore(risks);
            var riskMitigation = GenerateRiskMitigationPlan(risks);

            return new TimelineRiskAssessment
            {
                AssessmentId = assessmentId,
                OverallRiskScore = overallRiskScore,
                RiskLevel = DetermineRiskLevel(overallRiskScore),
                IdentifiedRisks = risks,
                MitigationPlan = riskMitigation,
                ContingencyRecommendations = GenerateContingencyRecommendations(risks),
                MonitoringStrategy = GenerateRiskMonitoringStrategy(risks),
                AssessmentDate = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error assessing timeline risks for assessment {AssessmentId}", assessmentId);
            throw;
        }
    }

    // Private helper methods (simplified for brevity)
    private async Task<PortfolioComplexity> CalculatePortfolioComplexity(List<Application> applications)
    {
        var complexityScores = applications.Select(CalculateApplicationComplexity).ToList();
        
        return new PortfolioComplexity
        {
            AverageComplexity = complexityScores.Average(),
            HighComplexityCount = complexityScores.Count(c => c > 7.0),
            TotalApplications = applications.Count
        };
    }

    private double CalculateApplicationComplexity(Application app)
    {
        double complexity = 1.0;
        
        // Technology stack complexity
        if (IsLegacyTechnology(app.TechnologyStack)) complexity += 2.0;
        if (app.TechnologyStack?.Contains("Mainframe") == true) complexity += 3.0;
        
        // Business criticality
        if (app.BusinessCriticality == "High") complexity += 1.5;
        if (app.BusinessCriticality == "Critical") complexity += 2.0;
        
        // User count impact
        if (app.UserCount > 1000) complexity += 1.0;
        if (app.UserCount > 10000) complexity += 2.0;
        
        return Math.Min(complexity, 10.0);
    }

    private bool IsLegacyTechnology(string technologyStack)
    {
        var legacyTechnologies = new[] { "COBOL", "Mainframe", "VB6", "PowerBuilder", "FoxPro", "Classic ASP", "VB.NET 2.0", "SQL Server 2008" };
        return legacyTechnologies.Any(tech => technologyStack?.Contains(tech) == true);
    }

    private async Task<DependencyAnalysis> AnalyzeApplicationDependencies(List<Application> applications)
    {
        var totalDependencies = applications.Sum(GetDependencyCount);
        var avgDependencies = applications.Count > 0 ? (double)totalDependencies / applications.Count : 0;
        
        return new DependencyAnalysis
        {
            CriticalDependencies = applications.Count(a => GetDependencyCount(a) > 5),
            IntegrationPoints = totalDependencies,
            AverageDependenciesPerApp = avgDependencies,
            RequiresInfrastructure = applications.Any(a => RequiresCustomInfrastructure(a))
        };
    }

    private int GetDependencyCount(Application app)
    {
        // Simplified dependency calculation
        int count = 0;
        if (!string.IsNullOrEmpty(app.DatabaseDependencies)) count += app.DatabaseDependencies.Split(',').Length;
        if (!string.IsNullOrEmpty(app.ExternalIntegrations)) count += app.ExternalIntegrations.Split(',').Length;
        return count;
    }

    private bool RequiresCustomInfrastructure(Application app)
    {
        return app.TechnologyStack?.Contains("Custom") == true || 
               app.TechnologyStack?.Contains("Legacy") == true;
    }

    private async Task<MigrationTimelinePrediction> ParseTimelinePrediction(string aiResponse, List<Application> applications, PortfolioComplexity complexity, DependencyAnalysis dependencies)
    {
        // Simplified parsing - in production, use structured AI response
        var baseTimelineDays = applications.Count * 10; // Base 10 days per application
        var complexityMultiplier = 1.0 + (complexity.AverageComplexity / 10.0);
        var dependencyMultiplier = 1.0 + (dependencies.AverageDependenciesPerApp / 20.0);
        
        var totalDays = (int)(baseTimelineDays * complexityMultiplier * dependencyMultiplier);
        
        return new MigrationTimelinePrediction
        {
            AssessmentId = applications.First().AssessmentId,
            OptimisticTimeline = TimeSpan.FromDays(totalDays * 0.8),
            RealisticTimeline = TimeSpan.FromDays(totalDays),
            PessimisticTimeline = TimeSpan.FromDays(totalDays * 1.4),
            PhaseBreakdown = new Dictionary<string, TimeSpan>
            {
                ["Assessment"] = TimeSpan.FromDays(totalDays * 0.15),
                ["Infrastructure"] = TimeSpan.FromDays(totalDays * 0.20),
                ["Migration"] = TimeSpan.FromDays(totalDays * 0.50),
                ["Testing"] = TimeSpan.FromDays(totalDays * 0.10),
                ["Deployment"] = TimeSpan.FromDays(totalDays * 0.05)
            },
            AIInsights = aiResponse
        };
    }

    private MigrationTimelinePrediction GenerateDefaultTimelinePrediction(string assessmentId)
    {
        return new MigrationTimelinePrediction
        {
            AssessmentId = assessmentId,
            OptimisticTimeline = TimeSpan.FromDays(90),
            RealisticTimeline = TimeSpan.FromDays(120),
            PessimisticTimeline = TimeSpan.FromDays(180),
            PhaseBreakdown = new Dictionary<string, TimeSpan>
            {
                ["Assessment"] = TimeSpan.FromDays(18),
                ["Infrastructure"] = TimeSpan.FromDays(24),
                ["Migration"] = TimeSpan.FromDays(60),
                ["Testing"] = TimeSpan.FromDays(12),
                ["Deployment"] = TimeSpan.FromDays(6)
            },
            ConfidenceScore = 0.5,
            GeneratedAt = DateTime.UtcNow
        };
    }

    private double CalculateConfidenceScore(PortfolioComplexity complexity, DependencyAnalysis dependencies)
    {
        double confidence = 1.0;
        
        // Reduce confidence based on complexity
        confidence -= (complexity.AverageComplexity / 10.0) * 0.2;
        
        // Reduce confidence based on dependencies
        confidence -= (dependencies.AverageDependenciesPerApp / 10.0) * 0.1;
        
        return Math.Max(0.3, Math.Min(0.95, confidence));
    }

    // Additional helper methods would be implemented here...
    private List<CriticalActivity> GeneratePhaseBreakdown(TimeSpan totalDuration) => new();
    private List<DateTime> CalculateMilestoneDates(TimeSpan totalDuration) => new();
    private TimeSpan CalculateCriticalPathDuration(List<CriticalActivity> activities) => TimeSpan.FromDays(120);
    private List<string> IdentifyCriticalPathBottlenecks(List<CriticalActivity> activities) => new();
    private List<string> IdentifyParallelizationOpportunities(List<CriticalActivity> activities) => new();
    private List<string> AnalyzeResourceConstraints(List<CriticalActivity> activities) => new();
    private List<string> GenerateCriticalPathOptimizations(List<CriticalActivity> activities) => new();
    private List<ResourceConstraint> AnalyzeResourceAvailability(List<Application> applications) => new();
    private TimeSpan EstimateApplicationMigrationDuration(Application app) => TimeSpan.FromDays(10);
    private List<string> GetApplicationDependencies(Application app, List<Application> allApps) => new();
    private ResourceType GetRequiredResourceType(Application app) => ResourceType.MigrationEngineer;
    private List<OptimizationSuggestion> GenerateParallelizationSuggestions(CriticalPathAnalysis analysis) => new();
    private List<OptimizationSuggestion> GenerateResourceOptimizations(CriticalPathAnalysis analysis, List<MigrationBottleneck> bottlenecks) => new();
    private List<OptimizationSuggestion> GenerateRiskMitigationOptimizations(List<MigrationBottleneck> bottlenecks) => new();
    private OptimizationComplexity CalculateImplementationComplexity(List<OptimizationSuggestion> suggestions) => OptimizationComplexity.Medium;
    private string DetermineRecommendedApproach(List<OptimizationSuggestion> suggestions, OptimizationCriteria criteria) => "Balanced approach";
    private string AssessOptimizationRisks(List<OptimizationSuggestion> suggestions) => "Medium risk";
    private string CalculateCostBenefitAnalysis(List<OptimizationSuggestion> suggestions) => "Positive ROI expected";
    private ResourceRequirement CalculateTotalResourceRequirement(List<PhaseResourceRequirement> phases) => new();
    private ResourceRequirement CalculatePeakResourceRequirement(List<PhaseResourceRequirement> phases) => new();
    private List<SkillGap> AnalyzeSkillGaps(List<PhaseResourceRequirement> phases, List<Application> applications) => new();
    private double CalculateOverallRiskScore(List<TimelineRisk> risks) => risks.Average(r => r.Probability * (int)r.Impact);
    private RiskLevel DetermineRiskLevel(double score) => score > 0.7 ? RiskLevel.High : score > 0.4 ? RiskLevel.Medium : RiskLevel.Low;
    private RiskMitigationPlan GenerateRiskMitigationPlan(List<TimelineRisk> risks) => new();
    private List<string> GenerateContingencyRecommendations(List<TimelineRisk> risks) => new();
    private RiskMonitoringStrategy GenerateRiskMonitoringStrategy(List<TimelineRisk> risks) => new();
}

// Supporting models and enums
public class PortfolioComplexity
{
    public double AverageComplexity { get; set; }
    public int HighComplexityCount { get; set; }
    public int TotalApplications { get; set; }
}

public class DependencyAnalysis
{
    public int CriticalDependencies { get; set; }
    public int IntegrationPoints { get; set; }
    public double AverageDependenciesPerApp { get; set; }
    public bool RequiresInfrastructure { get; set; }
}

public enum ResourceType
{
    ArchitectAnalyst,
    CloudEngineer,
    MigrationEngineer,
    DatabaseSpecialist,
    SecurityEngineer,
    DevOpsEngineer,
    QAEngineer
}

public enum RiskLevel
{
    Low,
    Medium,
    High,
    Critical
}

public enum BottleneckType
{
    Resource,
    Dependency,
    Technology,
    Process,
    External
}

public enum BottleneckImpact
{
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4
}

[Flags]
public enum OptimizationGoal
{
    Speed = 1,
    ResourceEfficiency = 2,
    CostOptimization = 4,
    RiskReduction = 8,
    QualityMaximization = 16
}

public enum OptimizationComplexity
{
    Low,
    Medium,
    High,
    VeryHigh
}

public enum ResourceCriticality
{
    Low,
    Medium,
    High,
    Critical
}

public enum RiskCategory
{
    Technical,
    Resource,
    Dependency,
    Scope,
    External,
    Business
}

public enum RiskImpact
{
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4
}